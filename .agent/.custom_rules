# Custom Rules for TripLog Project

## Project Overview
TripLog is an Android application for planning and documenting trips. Users can save memories, add photos, and check weather forecasts all in one place.

## Technology Stack
- **Language**: Kotlin
- **Architecture**: MVVM (Model-View-ViewModel)
- **Database**: Room
- **Network**: Retrofit
- **APIs**: OpenWeather API, Photon API (location search)
- **Min SDK**: 24 (Android 7.0)
- **Target SDK**: 36
- **Namespace**: com.example.triplog

## Development Guidelines

### Code Style
- Use Kotlin idiomatic code and follow Kotlin conventions
- Prefer data classes for entities and models
- Use coroutines for asynchronous operations
- Follow MVVM architecture pattern strictly
- Use ViewBinding for all views
- Apply proper separation of concerns

### Architecture
- **data/**: Database entities, DAOs (Room database layer)
- **network/**: API definitions, Retrofit instances
- **ui/**: Activities, ViewModels, Adapters (presentation layer)
  - Each feature should have its own package (login, register, main, profile, trips)
- **utils/**: Helper classes and utilities
- **config/**: Configuration files

### Database (Room)
- All entities must be in `data/entities/`
- All DAOs must be in `data/dao/`
- Use suspend functions for database operations
- Queries should return Flow or LiveData for reactive updates

### Network
- All API interfaces in `network/` package
- Use Retrofit with Gson converter
- API keys must be stored in `local.properties` (never commit them)
- Handle network errors gracefully with try-catch blocks
- Use coroutines for network calls

### ViewModels
- Each Activity with business logic should have a corresponding ViewModel
- Use ViewModelFactory when constructor parameters are needed
- Expose LiveData/StateFlow to observe data changes
- Never hold references to Activities or Views in ViewModels

### UI Components
- Use Material Design components
- Follow the existing color scheme and theming
- Implement proper error handling and user feedback (Toasts, Snackbars)
- Support Polish language (UI text should be in Polish)
- Use RecyclerView with custom adapters for lists

### Image Handling
- Use ExifInterface for proper image orientation
- Store image paths in database, not the images themselves
- Support multiple images per trip

### API Keys & Secrets
- Store all API keys in `local.properties`
- Never commit `local.properties` to git
- Provide `local.properties.example` as a template
- Access keys via BuildConfig in code
- Example: `val apiKey = getLocalProperty("OPENWEATHER_API_KEY")`

### Testing
- Write unit tests in `test/` directory
- Write instrumented tests in `androidTest/` directory
- Test ViewModels and business logic
- Test database operations

### Dependencies
- Always use version catalogs (`libs.versions.toml`)
- Keep dependencies up to date
- Use kapt for annotation processing (Room)

### Git Workflow
- Follow conventional commits
- Use meaningful commit messages in Polish or English
- Don't commit build files, IDE configs, or API keys

### Error Handling
- Always handle null cases
- Use try-catch for network and database operations
- Provide user-friendly error messages in Polish
- Log errors for debugging

### Performance
- Use pagination for large lists
- Optimize image loading and caching
- Minimize database queries
- Use background threads for heavy operations

### Security
- Hash passwords before storing (use PasswordHasher utility)
- Validate user input
- Use SharedPreferences for simple data storage
- Never log sensitive information

### UI/UX Standards
- All user-facing text should be in Polish
- Use consistent spacing and margins
- Implement loading states for async operations
- Show appropriate feedback for user actions
- Follow Material Design guidelines

## When Making Changes

### Adding New Features
1. Create necessary entities/DAOs in data layer
2. Create API interfaces if network is needed
3. Create ViewModel for business logic
4. Create Activity/Fragment for UI
5. Add navigation in MainActivity
6. Update README if user-facing

### Modifying Existing Code
1. Maintain MVVM architecture
2. Keep backward compatibility
3. Update tests if logic changes
4. Follow existing patterns and conventions

### API Integration
1. Define interface in `network/` package
2. Add to RetrofitInstance if needed
3. Handle responses in ViewModel
4. Display data in Activity/Fragment

### Database Changes
1. Update entity classes
2. Increment database version in AppDatabase
3. Provide migration strategy if needed
4. Update DAO queries

## Common Patterns

### Activity Structure
```kotlin
class ExampleActivity : AppCompatActivity() {
    private lateinit var binding: ActivityExampleBinding
    private lateinit var viewModel: ExampleViewModel
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityExampleBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        viewModel = ViewModelProvider(this, ExampleViewModelFactory(dao))
            .get(ExampleViewModel::class.java)
        
        setupObservers()
        setupListeners()
    }
}
```

### ViewModel Structure
```kotlin
class ExampleViewModel(private val dao: ExampleDao) : ViewModel() {
    private val _data = MutableLiveData<List<Example>>()
    val data: LiveData<List<Example>> = _data
    
    fun loadData() {
        viewModelScope.launch {
            try {
                val result = dao.getAll()
                _data.postValue(result)
            } catch (e: Exception) {
                // Handle error
            }
        }
    }
}
```

### Network Call Pattern
```kotlin
viewModelScope.launch {
    try {
        val response = api.getData()
        if (response.isSuccessful) {
            // Handle success
        } else {
            // Handle error
        }
    } catch (e: Exception) {
        // Handle network error
    }
}
```

## Important Notes
- This is a personal project by @sh3ev
- The app is in Polish language
- OpenWeather API key is required for functionality
- Follow MIT License terms
